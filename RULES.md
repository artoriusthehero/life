<strong>Rule 1: All variables are equal.</strong>

This comes from the logic that life == life and life is big. It contains everything so it equates to everything. HOWEVER. WHEN WE, count it, WE maintain
the assumtion that life is pure, or life is upsetting, or life is whatever, that CHANGES US SOMEHOW ON A MOLECULAR LEVEL, this changes our neural net structure,
this codes us. And the way it does that is very simple, it takes the logic life == life and beats you over the head with how true that is everywhere. You're
free to redefine life, but life == life would always be true. So everything's true? No, life != life is NOT TRUE. 

Thanks.

<strong>Rule 2: Power is always right.</strong>

So we know that life == life. hotdogs == hodogs but hotdogs do not = hotdog because then life would be hotdog. You can even feel it. You are free to say life ==,
because == (as we all know) checks for true or false and returns it. A REGULAR = sign just sets a variable. You can check for truth and it'll always come up true
unless you try to fight it, if you fight it, chances are it'll fight back. NOT TRUE! you say, well, according to MY LOGIC! You're wrong. 

<strong>Rule 3: You're free to define anything</strong>

Just as we say, we're free to use that = sign just for fun, what happens is humor is formed, a lot of things are formed. Variables are formed. ONLY EVERY SINGLE
VARIABLE GETS CHANGED TO IT! OH MY GOD!

Example:

Life = Good. NO! life == good. Never break the matrix, your brain will actually lag. IT'LL DO IT, but don't. 

However, you are free and nurtured to define FUNCTIONS! Why? It's just like programming, if you redefine variables all day, your boss will get worried.
```
Life(){
  Good();
}
```
// when you nest a function, you just let life call good, you don't change defintion. That's nice of you.

That shit is encouraged, that is a nested function. Look at you. However, if you're lazy and just say life is good, an evil programmer can always say "life = evil"  
or add shit to your function. It could even be yourself. ALL THAT MATTERS IS YOU DON'T GIVE UP! Life is a concept and we're thinking about it wayy to simply.
Applying everything, I find great discounts on belief. The problem with having "sarcasm" or "inherent design" in code is that it makes you lazy where hackers
aren't. And you can be hacked, you're connected to everything. You're connection to logic is firm as it is connected to creativity. So you're connected to all.

The only problem we have here isn't with our algorithm, it's what we don't see. GOOD has nested shit, just throughout the day you add stuff to it and it could
be wrong. Like cigarettes for instance. Or having no fear, being fearless is good. Is it? I don't know, which means I'm wrong, but I know everything is equal
to each other, so I know what everything is, and if I don't I'm really not in touch with my feelings, are I?
```
Life(){
	Good(){
		cigs();
		poultry(){
			killing(){
				bad;
				}
			}
		}
	}
}
```
It gets tricky, so can we say that life is good? NO. So that one's a lie. I think God said it? Definetely the bible, so that would make God a liar.
So that's why "life is good" doesn't play well in our head unless the programmer is fine with a lot of things. That would be blessed to a point of disbelief.
To think killing was justified just to make life good? That's satanic on a principal that I don't get it, but the computer can run it. So this programming
language is inherently satanic, which means we are too. BUT MATH MAN, GOOD == BAD! That's true, but it's also somehow satanic? Which makes it cool. Does it
make it wrong? No. It's only wrong unless you don't know. You say, "I know that statement doesn't work." So you have to go satanic. Ready for this? You're going to be a badass... Life == Good && Bad. So then you have a class for sorting logic.
```
Life(){
	Good(){
		**rage equation**
	}
	Bad(){
		**rage equation**
	}
}
Console: I have fear in my heart that this doesn't work.
#We forgot to account for other and add a switch case.
Life(){
	switch{
		case Good(){
			**rage equation**
		}
		case Bad(){
			**rage equation**
		}
		case Other(){
			**nice equation**
		}
	}
}	
```
So we can divert into this path of nested functions, and we're free to define it as we like, but for life to make sense, we have to keep them separate.
Why? Because they're opposites. But then... If everything is opposite to each other, how does life work? *In the grey areas.

So before I get onto the next rule, what did we learn? That life creates problems sometimes.

<strong>Rule 4: It runs off time and belief</strong>

This is true, like any programming language, it takes time, and you can only process one statement at a time. That being said, our belief takes processing power.
So if you find that you can't believe something, it could just be taking a lot of time to process. Just like this rage coding:

Buddha or some guy probably thought a way around rules and came up with a function that went like this
```
Life = Unstable;
You = Stable;
```
There's a lot wrong here, one, we're doing a no no from earlier, we're saying you and life have separate definitions. The truth is that when you process life as
unstable, you forget it's unstable by the time you define You. Believe it or not, this is why people forget contradictions a lot more often than things that
make perfect and clear sense. The only reason we don't forget life is because we're forced to be in it. So keep that in mind, it'll be on the test later.

So how do we fix it?
Well, nesting a function could work, but lets just check it out.

```
function life(){
	this.you{
		stable;
		if (other && good){
			be happy;
		} else{
			be else;
		}
	unstable;#remember this line for life
	if (other){
		return true;
	}
}
```
So this is even more fucked up. It defines everything as stable, then checks for other while good, ignores all of it, sets itself to unstable, checks for other,
and doesn't get anything. So it's a headache. So can we say that life is stable and we're unstable? No, we have to say we're everything. Everytime. And suddenly...
```
if (life == stable){
	you = stable;
}
```
So buddha or whoever was defining variables didn't have to define shit. You just use an if statement that checks for the galgatron global variable that's always
true no matter what. Pretty simple.

SO BELIEVE IT. As far as time goes, all I want to say right now is that we work like a software, we have a clock, memory, we run logic that may or may not work,
and we keep on living regardless of whether it works out or not. But remember, all time means is that you're processing one line at a time. Bit for bit, translating, working. Becoming one. 

One more thing. Belief. If you say you don't believe it at any point, it'll glitch out. That's all that will happen, the software will still ask for shit, you
can never escape. It's satanic. So believe what you can prove and only what you can prove. 

<strong>RULE 5: You always know everything</strong>

Simply put, if you ever run into something about this language you don't know, you already do. And if you don't know concretely, you can check it with this
programming language, I gaurantee it'll come up weirdly. Logic has a weird way of contradicting itself on a hidden level, but if you follow these rules, you
can datamine a way of putting it that makes sense. In that respect, you are God. You are connected to life and you know everything. 
